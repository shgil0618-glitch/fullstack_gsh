
# 🚀 실행력과 협업에 강한 풀스택 개발자 – 길상현의 개발 여정

> 완벽에 머무르기보다, **끝까지 완성해내는 개발자**
> 기획부터 배포까지 전 과정을 주도하며, **사용자 흐름을 설계하고 문제를 끝까지 해결**해왔습니다.

단순한 기능 구현을 넘어,
**CS 기반의 구조적 문제 해결 능력**과
**팀 프로젝트에서의 실전 협업 경험**으로 
현장에서 바로 통하는 역량을 증명해왔습니다.

<br/>
<br/>

---
<!-- 이미지 (조절하는 법) -->
<!-- 이름, 이메일, 깃허브주소, 포트폴리오  2*4의 테이블 형식으로 -->
## Contact & Link

<!-- ![프로필](./userimage.png) -->
<img src="./userimage.png" alt="프로필" width = "100">

| | |
|-|-|
|이름|길상현|
|이메일|shgil0618@gmail.com|
|깃허브주소|https://github.com/shgil0618-glitch/fullstack_gsh.git|
<!--
|포트폴리오|**추후 추가예정**|
-->

<br/>
<br/>

---

## 📌 Golds – 실무 중심의 개발 역량 강화 목표

* **GitHub 핵심 기능을 직접 실습하며**, 버전 관리와 협업에 필요한 기초를 탄탄히 다졌습니다.
* **Markdown을 활용한 개발 문서화** 역량을 키워, 누구나 이해할 수 있는 기록을 남기는 습관을 길렀습니다.
* **GitHub Workflow를 실전 프로젝트에 적용**, 팀원과의 효율적인 협업을 경험하며 CI/CD 개념의 기초도 익혔습니다.
* **AI 도구(GitHub Copilot 등)를 활용한 개발 환경을 체험**, 생산성과 학습 효율을 높이는 방법을 적극적으로 탐구했습니다.


<br/>
<br/>

<!-- cs와 연결지어서
---

### 📌 기술 스택 & 실무 기반 CS 역량 

| 기술 스택                        | 역할 및 기능 이해                  | 실무적 활용 및 경험 포인트                               |
| ---------------------------- | --------------------------- | --------------------------------------------- |
| **Git & GitHub**             | 분산 버전 관리, 브랜치 전략, 협업 워크플로우  | PR 리뷰, Merge Conflict 해결, Git Flow 적용 프로젝트 경험 |
| **Markdown**                 | 기술 문서 작성, README, 회고 문서화 도구 | 협업 문서/이슈 템플릿 작성, Notion 연동 정리 습관화             |
| **VS Code**                  | 경량 IDE, 디버깅, 확장 기능 구성       | GitLens, Live Server, Copilot 등 실무 확장 기능 활용   |
| **HTML5**                    | 시맨틱 구조, 접근성 고려 마크업          | 구조적 DOM 설계, SEO 및 스크린리더 고려 개발 경험              |
| **CSS3**                     | 반응형 레이아웃, Flex/Grid, 애니메이션  | 모바일 대응 UI, 미디어쿼리 활용 경험                        |
| **AI 도구 (Copilot, ChatGPT)** | 생산성 도구, 코드 힌트, 에러 진단 보조     | 코드 리뷰/리팩토링 보조, 모르는 개념 검증 및 빠른 테스트             |


### ✅ 실무진이 좋아하는 구성 포인트:

* **왼쪽 → 기술 명칭**, 가운데 → **기술 개념**, 오른쪽 → **어떻게 활용했는지**
* 실전 경험이 보이는 **구체 키워드 포함** (예: conflict 해결, Git Flow, 반응형 UI)
* 단순히 "할 줄 안다"가 아니라 **이해하고 활용했다**는 점을 강조
-->

<!--
1. 개발자 포트폴리오 readme.md 작성중인데, 이 기술스택을 보고 실무진들이 바로 뽑아야겠다라는 생각이 들게 다음의 기술스택을 cs역량과 연결지어서 작성해줘.

2. 위의 내용에서 활용능력부분에서 강조할부분을 굵고 색상들어가게해줘
-->

<!--
---

## 📌 기술스택 기반 CS역량

* **Git & GitHub**

  * 분산 버전 관리 시스템(DVCS)의 원리 이해 및 활용
  * 협업 과정에서 <b style="color:#f39c12">브랜치 전략(Git Flow, Trunk-based)</b> 적용 → 안정적인 개발 사이클 유지
  * 충돌 해결 및 코드 리뷰 경험을 통한 <b style="color:#27ae60">소프트웨어 공학적 협업 역량</b> 확보

* **Markdown**

  * <b style="color:#3498db">가독성 높은 문서화</b> 및 개발 문서 작성 능력
  * README, API 문서, 위키를 통해 <b style="color:#27ae60">기술 커뮤니케이션 역량</b> 강화
  * 명확한 표현으로 <b style="color:#9b59b6">팀 생산성 극대화</b>

* **VS Code**

  * 확장 플러그인 기반 <b style="color:#f39c12">개발 환경 최적화</b> 능력
  * <b style="color:#27ae60">디버깅 · Linting · Formatter</b> 적용을 통한 코드 품질 관리

* **HTML5**

  * 시맨틱 태그 활용으로 <b style="color:#27ae60">정보 구조화 및 접근성 개선</b>
  * DOM과 웹 표준 이해로 <b style="color:#3498db">크로스 플랫폼 호환성 보장</b>

* **CSS3**

  * Flexbox · Grid 시스템을 통한 <b style="color:#f39c12">효율적 레이아웃 설계</b>
  * 애니메이션 · 반응형 디자인 적용 → <b style="color:#27ae60">사용자 경험(UX) 최적화</b>

* **AI 프롬프트 엔지니어링**

  * 자연어 입력 구조 최적화로 <b style="color:#f39c12">문제 정의 및 요구사항 추출</b>
  * 프롬프트 최적화를 통한 <b style="color:#27ae60">자동화 · 생산성 증대</b>
  * AI 협업을 통한 <b style="color:#9b59b6">문제 해결 능력 가속화</b>
-->
---

## 📌 기술스택 기반 CS역량

| 기술스택                         | CS 기반 이해                   | 활용 능력                                                                                                                                                                  |
| ---------------------------- | -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Git & GitHub**             | 분산 버전 관리 시스템(DVCS), 브랜치 전략 | 협업 과정에서 <b style="color:#f39c12">브랜치 전략(Git Flow, Trunk-based)</b> 적용, 충돌 해결 및 코드 리뷰를 통한 <b style="color:#27ae60">소프트웨어 공학적 협업 역량</b> 확보                               |
| **Markdown**                 | 문서 구조화, 개발 지식 전달           | <b style="color:#3498db">가독성 높은 문서화</b> 및 README, API 문서, 위키 작성 → <b style="color:#27ae60">기술 커뮤니케이션 역량</b> 강화, 명확한 표현으로 <b style="color:#9b59b6">팀 생산성 극대화</b>        |
| **VS Code**                  | IDE 동작 원리, 코드 품질 관리        | 확장 플러그인 기반 <b style="color:#f39c12">개발 환경 최적화</b>, <b style="color:#27ae60">디버깅 · Linting · Formatter</b> 적용을 통한 코드 품질 관리                                              |
| **HTML5**                    | 웹 표준, DOM 구조, 시맨틱 태그       | 시맨틱 태그 활용으로 <b style="color:#27ae60">정보 구조화 및 접근성 개선</b>, DOM 및 웹 표준 이해로 <b style="color:#3498db">크로스 플랫폼 호환성 보장</b>                                                   |
| **CSS3**                     | 렌더링 엔진, 박스 모델, 레이아웃 알고리즘   | Flexbox · Grid 시스템을 통한 <b style="color:#f39c12">효율적 레이아웃 설계</b>, 애니메이션 및 반응형 디자인 적용으로 <b style="color:#27ae60">사용자 경험(UX) 최적화</b>                                      |
| **AI 도구 (Copilot, ChatGPT)** | NLP 모델 구조, AI 기반 자동화 활용    | 자연어 입력 구조 최적화로 <b style="color:#f39c12">문제 정의 및 요구사항 추출</b>, 프롬프트 최적화를 통한 <b style="color:#27ae60">자동화 · 생산성 증대</b>, AI 협업으로 <b style="color:#9b59b6">문제 해결 능력 가속화</b> |


<br/>
<br/>

---

## 📌 트러블 슈팅 (github에서 발생)
<br/>

### ▶트러블 슈팅(1)

```bash
$ git commit -m "git 수정 후 다시올리기"
On branch master
Changes not staged for commit:
        modified:   day001.md
no changes added to commit (use "git add" and/or "git commit -a")
```

1. **문제점**

   * 파일을 수정했지만 `git add` 단계 없이 커밋을 시도
   * 실제 원인은 수정한 파일을 **저장하지 않고 커밋**하려 한 것

2. **해결방안**

   * 저장 후 다시 `git add` 및 `git commit` 진행


3. **느낀점**

   * 너무 기본적인 부분에서 문제가 발생할 수 있음을 깨달음
   * 사소한 습관(파일 저장)을 소홀히 하면 불필요하게 시간을 낭비하게 됨
   * 앞으로는 **커밋 전 저장 확인 → ctrl+s 혹은 git status 확인** 습관을 들여야 함

<br/>

### ▶트러블 슈팅(2)

```bash
$ git push origin master
! [rejected]        master -> master (fetch first)
error: failed to push some refs to '...'
hint: Updates were rejected because the remote contains work that you do not
hint: have locally. ...
```

1. **문제점**

   * 로컬 브랜치가 GitHub 최신 상태보다 뒤처져 있었음
   * 협업 상황에서 최신 내용을 가져오지 않고 곧바로 `push` 시도

2. **해결방안**

   1. `git add .`
   2. `git commit -m "메시지"`
   3. `git pull origin master` (원격 변경사항 병합)
   4. `git push origin master`

3. **느낀점**

   * 협업 환경에서는 언제든 원격 상태가 바뀔 수 있다는 사실을 명심해야 함
   * `push` 전에 **반드시 pull → 상태 확인 → 병합** 과정을 거쳐야 충돌을 줄일 수 있음
   * 습관적으로 **git pull → 코드 확인 → push** 루틴을 가져야 함

<br/>

### ▶트러블 슈팅(3)

```bash
$ git pull origin master
...
CONFLICT (content): Merge conflict in day002.md
Automatic merge failed; fix conflicts and then commit the result.
```

1. **문제점**

   * 원격 저장소와 로컬 저장소의 동일 파일(day002.md)이 서로 다르게 수정됨
   * 자동 병합 불가능 → **merge conflict 발생**

2. **해결방안**

   * 충돌 난 로컬파일(`day002.md`)을 열어 수동으로 수정
   * 수정 후 `git add day002.md` → `git commit` 으로 병합 완료
   * 이후 정상적으로 `git push`

3. **느낀점**

   * 충돌은 협업 개발에서 자연스러운 과정이라는 점을 이해
   * 무조건 에러로 인식하기보다, **내용 비교 & 합의된 기준으로 수정**하는 습관 필요
   * 충돌 상황은 **커뮤니케이션 역량 + 코드 이해력**이 함께 요구된다는 점을 배움

<br/>
<br/>


### ▶트러블 슈팅(4)

```bash
$ git push origin master
To https://github.com/shgil0618-glitch/fullstack_gsh.git
 ! [rejected]        master -> master (fetch first)
error: failed to push some refs to 'https://github.com/shgil0618-glitch/fullstack_gsh.git'
hint: Updates were rejected because the remote contains work that you do not
hint: have locally. This is usually caused by another repository pushing to
the same ref. If you want to integrate the remote changes, use
'git pull' before pushing again.
```

1. **문제점**

   * 로컬 브랜치(master)와 원격 브랜치(origin/master)의 커밋 히스토리가 서로 달라 발생
   * 원격 저장소에 추가된 커밋을 로컬이 반영하지 못한 상태에서 push를 시도했기 때문에 거절됨
   * 단순 `git pull`을 하면 자동으로 merge commit이 생성되어, 커밋 히스토리가 지저분해질 수 있음

2. **해결방안**

   * `--rebase` 옵션을 사용하여 원격 브랜치의 커밋을 먼저 가져온 뒤, 로컬 커밋을 그 위에 재적용

   ```bash
   git pull origin master --rebase
   ```

   * rebase 도중 충돌(conflict) 발생 시 → 해당 파일을 수정하고 `git add` 후 진행
   ```bash
   git rebase --continue
   ```

   * 불필요한 merge commit 없이, 선형적인 커밋 히스토리 유지 가능
   
   * 모든 충돌 해결 및 rebase 종료 후 정상적으로 push
   ```bash
   git push origin master
   ```

3. **느낀점**

   * 단순히 충돌을 피하는 것보다, **프로젝트 히스토리를 깔끔하게 관리하는 방법**이 더 중요하다는 걸 깨달음
   * `git pull --rebase`는 협업 시 발생할 수 있는 "불필요한 merge commit" 문제를 줄여주어, 로그 가독성을 크게 높임
   * 단순 문제 해결을 넘어서, 왜 특정 전략(rebase)을 선택해야 하는지를 이해하고 설명할 수 있게 됨

<br/>
<br/>

### ▶트러블 슈팅(5)

```bash
PS D:\gilsanghyun\teacher> git push origin dev-gsh
Enumerating objects: 7, done.
Counting objects: 100% (7/7), done.
Delta compression using up to 4 threads
Compressing objects: 100% (4/4), done.
Writing objects: 100% (6/6), 505 bytes | 505.00 KiB/s, done.
Total 6 (delta 2), reused 0 (delta 0), pack-reused 0 (from 0)
remote: Resolving deltas: 100% (2/2), completed with 1 local object.
To https://github.com/tkasid00/fullstack_20250825.git/
 ! [remote rejected] dev-gsh -> dev-gsh (permission denied)
error: failed to push some refs to 'https://github.com/tkasid00/fullstack_20250825.git/'
```

1. **문제점**

   * 푸시를 시도한 **`dev-gsh`** 브랜치에 대해 **`permission denied`** 에러가 발생
   * **원격 리포지토리의 URL**이 **잘못 지정**되어 있어 푸시할 권한이 없는 다른 리포지토리로 푸시하려고 시도한 경우

     * 에러 메시지에서 `https://github.com/tkasid00/fullstack_20250825.git/`와 같은 URL이 출력되는데, 이는 **원하는 리포지토리가 아닌 다른 리포지토리**에 푸시를 시도한 것
   * 이 문제는 리모트 URL 설정을 꼼꼼히 확인하지 않았기 때문에 발생함

2. **해결방안**

   * **리모트 URL 확인**: 먼저, 현재 리모트 저장소 URL이 올바른지 확인

     ```bash
     git remote -v
     ```

     * 위 명령어로 출력된 리모트 URL이 **내 리포지토리**로 지정되어 있는지 점검

   * **리모트 URL 수정**: 잘못된 URL이 설정된 경우, 올바른 리모트 URL로 수정

     ```bash
     git remote set-url origin https://github.com/내_사용자명/내_리포지토리.git
     ```

   * **다시 푸시 시도**: 리모트 URL을 수정한 후, 푸시 명령어를 다시 실행

     ```bash
     git push origin dev-gsh
     ```

3. **느낀점**

   * Git을 사용할 때 **리모트 URL** 설정이 얼마나 중요한지 다시 한 번 깨달음. URL 설정이 잘못되면 푸시할 권한이 없는 리포지토리로 데이터를 보내는 상황이 발생할 수 있음
   * **리모트 URL**은 **협업 환경**에서 특히 중요한 요소이므로, 작업을 시작하기 전에 항상 확인하는 습관을 들여야겠다고 생각함
   * 문제를 해결하는 과정에서 **Git의 리모트 설정**을 보다 깊이 이해할 수 있었고, 앞으로는 꼼꼼히 점검할 필요성을 느꼈음


<br/>
<br/>

### ▶트러블 슈팅(6)


```bash
PS D:\HYUNJU\workspace\fullstack_20250825> git push origin dev-tkasid00
remote: Permission to tkasid00/fullstack_20250825.git denied to HSH703.
fatal: unable to access 'https://github.com/tkasid00/fullstack_20250825.git/': The requested URL returned error: 403
```


1. **문제점**

   * 현재 GitHub에 로그인된 계정(HSH703)은 `tkasid00` 저장소에 푸쉬 권한이 없음.
   * 권한 부족으로 인해 푸쉬 작업이 실패.

2. **해결방안**

   * `tkasid00` 계정에서 HSH703 계정에게 **Collaborator** 권한을 부여해야 함.
   * 권한 부여 방법:

     1. GitHub에서 `tkasid00` 계정으로 로그인
     2. 해당 저장소로 이동하여 **Settings** 메뉴 클릭
     3. **Collaborators** 메뉴로 이동
     4. HSH703 계정을 초대하여 권한 부여

3. **느낀점**

   * 협업 시 **권한 관리**의 중요성을 실감함.
   * 푸쉬 권한이 없을 경우 발생하는 **권한 에러**를 해결하는 방법을 배움.
   * GitHub에서의 **접근 권한 설정**은 협업의 기본이고, 이를 제대로 관리하는 것이 매우 중요하다는 점을 깨달음.


<br/>
<br/>

---

## 📌 트러블 슈팅 (Web에서 발생)
<br/>


### ▶ 트러블슈팅 (1)

```html
<div style="width: 300px; border: 3px solid red; text-align: center;">
    <p>박스 가운데 정렬 텍스트</p>
</div>
```

1. **문제점**

* `text-align: center;`를 적용했지만 박스가 **페이지 중앙에 위치하지 않음**
* margin, padding, border 등 **박스 모델 이해 부족**으로 시각적으로 정렬이 맞지 않음

2. **해결방안**

* 박스를 화면 중앙으로 배치 → `margin: 0 auto;`
* 박스 안 텍스트 중앙 정렬 → `text-align: center;`

```html
<div style="width: 300px; border: 3px solid red; margin: 0 auto; text-align: center;">
    <p>박스 가운데 정렬 텍스트</p>
</div>
```

3. **느낀점**

* CSS에서 **박스 모델과 속성 상호작용**을 이해해야 레이아웃 문제를 해결할 수 있음
* 단순 `text-align`만으로는 전체 레이아웃을 조정할 수 없다는 것을 깨달음
* 앞으로 레이아웃 설계 시 **박스 모델 관점에서 접근**하는 습관을 갖게 됨

<br/>

### ▶ 트러블슈팅 (2)

```html
<img src="./img/userimage.png" style="width: 150px; border: 3px solid red;">
```

1. **문제점**

* 테두리를 적용했지만 **이미지가 직사각형**으로 표시됨 → 원형 테두리 의도 실패
* 디자인 디테일 부족으로 UI/UX 측면에서 시각적 불완전

2. **해결방안**

* 이미지 원형으로 만들기 → `border-radius: 50%;`
* 테두리 유지 → `border: 3px solid red;`

```html
<img src="./img/userimage.png" style="width: 150px; border-radius: 50%; border: 3px solid red;">
```


3. **느낀점**

* CSS 속성 하나로 **디자인 완성도가 크게 달라짐**을 체감
* 작은 디테일도 사용자의 시각적 경험에 큰 영향을 준다는 것을 깨달음
* 앞으로는 **UI 디테일에도 주의를 기울이는 습관**을 갖게 됨

<br/>
<br/>

### ▶ 트러블슈팅 (3)

```html
<dl>
  <dt>문제점</dt>
  <dd>트러블슈팅 작성 시, 설명 부분이 자동으로 들여쓰기(margin-left: 40px)가 적용됨</dd>

  <dt>해결방안</dt>
  <dd>CSS 초기화 또는 사용자 정의 스타일 적용</dd>
</dl>
```


1. **문제점**

* `<dd>` 태그는 브라우저 기본 스타일로 \*\*`margin-left: 40px`\*\*가 적용됨
* 문서에서 일정한 레이아웃을 만들고 싶은데, 의도치 않은 들여쓰기로 인해 디자인 불균형 발생
* 웹 표준 태그를 사용했지만, 브라우저 기본 스타일을 그대로 두면 **UI 일관성 저해**


2. **해결방안**

* CSS로 기본 margin을 초기화 후, 원하는 값으로 재설정
* 필요 시, `<dl>`을 문서 뼈대로 유지하면서 **공통 스타일 정의**

```html
<style>
  dl {
    margin: 0;
    padding: 0;
  }
  dt {
    font-weight: bold;
    margin-top: 10px;
  }
  dd {
    margin: 0 0 10px 20px; /* 기본 40px 대신 원하는 값으로 조정 */
  }
</style>

<dl>
  <dt>문제점</dt>
  <dd>브라우저 기본 margin-left로 인해 문서 레이아웃이 어긋남</dd>

  <dt>해결방안</dt>
  <dd>CSS 초기화 후 원하는 margin 값으로 통일</dd>
</dl>
```


3. **느낀점**

* HTML 태그는 단순 구조뿐 아니라 **브라우저 기본 스타일**까지 이해해야 안정적인 뼈대를 설계할 수 있다는 점을 배움
* 개발 단계에서 기본값을 의식하고, **CSS로 일관된 디자인을 컨트롤**하는 습관이 필요함
* 웹 개발은 기능뿐만 아니라 **“구조(HTML) → 기본 스타일(CSS Reset/Normalize) → 커스터마이징”** 흐름이 중요함을 깨달음


<br/>


---

### ▶ 트러블슈팅 (4)

```css
.container.mission {
  margin: 30px;
  padding: 20px;
  background-color: #2980b9;
  border-radius: 10px;
}
/* 띄어쓰기 없이 써야함 // 띄어쓰기 하면 자식 처리됨, 우선순위 밀리게 됨 */
```

<br/>

1. **문제점**

* `.container.mission` 선택자를 작성할 때, 실수로 `띄어쓰기`를 넣어 `.container .mission`으로 작성하면 의도한 스타일이 적용되지 않음
* 원래는 하나의 **요소에 두 개의 클래스**가 모두 적용된 경우에 스타일을 적용하고 싶었는데,
  띄어쓰기를 넣으면 **자식 선택자**로 인식됨

```css
/* 잘못된 예 */
.container .mission {
  /* .container 내부에 있는 .mission 자식 요소에만 적용됨 */
}
```

* 이로 인해 특정 요소에 기대한 스타일이 **전혀 적용되지 않거나**,
  다른 CSS 규칙보다 우선순위가 밀려 **덮어쓰기 되지 않는 현상** 발생



2. **해결방안**

* 클래스 선택자 사이에는 **띄어쓰기 없이** 작성해야 같은 요소에 두 클래스가 모두 적용된 경우를 의미함

```css
/* 올바른 예 */
.container.mission {
  /* .container와 .mission 클래스를 모두 가진 요소에 적용 */
}
```

* 이렇게 하면 해당 요소가 `.container`와 `.mission` 클래스를 **동시에** 가질 때에만 스타일이 정확히 적용됨
* CSS 선택자의 **결합 방식과 의미 차이**를 명확히 인지하고 코딩해야 함


3. **느낀점**

* CSS 선택자에서 **띄어쓰기 유무에 따라 의미가 완전히 달라짐**
  → `.a .b`는 자식 요소, `.a.b`는 동일 요소 내의 다중 클래스

* 이는 시각적으로는 아주 미세한 차이지만, 결과적으로 스타일이 **전혀 적용되지 않거나**,
  다른 요소에 **의도치 않게 적용되는 버그**로 이어질 수 있음

* 특히 협업이나 유지보수 시, **우선순위 충돌과 적용 범위 문제**를 피하려면
  선택자의 \*\*범위(Scope)\*\*와 \*\*구조(관계)\*\*를 명확히 설계하고,
  **CSS 선택자 체계에 대한 정확한 이해**가 필요


💡 **핵심 정리**

> `.a .b` → **자식 선택자** (공간적으로 분리된 요소)
> `.a.b` → **동일 요소 내 다중 클래스 선택자** (띄어쓰기 없이!)

---

## 📌 트러블 슈팅 (Java에서 발생)
<br/>

### ▶트러블 슈팅(1)

```java
package com.company.Java001_ex;

public class A003_ex {
    public static void main(string[] args) {
        System.out.printf("이름 : %s  나이: %d", "길동", 12);
    }
}
```
```bash
Error:(5, 24) java: cannot find symbol
  symbol:   class string
  location: class com.company.java001_ex.A003_ex
```

1. **문제점**
   * Java는 **대소문자를 엄격히 구분**하기 때문에, `string`과 같은 잘못된 표기는 컴파일 에러를 발생시킨다. 또한, 패키지명은 관례적으로 **소문자**를 사용해야 가독성과 유지보수성이 높아진다.

2. **해결방안**
   * `string[] args` → `String[] args` 로 수정하여 올바른 타입 지정
   * `package com.company.Java001_ex;` → `package com.company.java001_ex;` 로 변경하여 네이밍 컨벤션 준수

3. **느낀점**
   * 이번 오류를 통해 **사소해 보이는 대소문자 차이도 프로그램 실행 여부에 직접적인 영향을 준다는 것**을 다시 한 번 체감했다. 앞으로는 단순히 코드를 작성하는 것에서 끝나지 않고, **언어의 문법적 특징과 컨벤션을 의식적으로 지키는 습관**을 들여 더 안정적이고 읽기 쉬운 코드를 작성해야겠다.

<br/>

### ▶트러블 슈팅(2)

```java
public class VarEx002 {
	public static void main(String[] args) {
		int a;
		a = 10;
		int b;
		b = 3;
		float c;
		c = a/b;
		System.out.println("10 / 3 =" +(a/b));
		System.out.println("10 / 3 = "+c);	
		System.out.printf("%d / %d = %f\n",a,b,c);
   }
}
```
```bash
결과값
10 / 3 = 3
10 / 3 = 3.0
10 / 3 = 3.000000
```

1. **문제점**
   * 변수 c를 float로 선언했음에도 불구하고 결과가 3.0, 3.000000으로 정수 나눗셈 결과를 그대로 보여줌
   * 이유: a와 b가 정수형(int) 이므로, 나눗셈 연산 a/b가 정수 나눗셈으로 수행됨 → 소수점 이하가 버려짐
   * 즉, 실수형 변수에 저장했더라도 연산 과정 자체가 정수라 실제 계산값은 이미 손실됨

2. **해결방안**
   * 나눗셈을 수행하기 전에 한쪽 혹은 양쪽을 실수형으로 캐스팅
```java
   c = (float)a / b;
```

3. **느낀점**
   * 겉보기에는 변수 타입만 바꿔도 될 것 같지만, 연산 과정에서 자료형이 우선적으로 적용됨을 깨달음
   * 사소한 타입 문제 하나가 결과를 완전히 달라지게 할 수 있다는 점에서 자료형 선택과 연산 순서의 중요성을 배웠음
   * 앞으로는 실수 연산 시 정수/실수 타입 구분을 명확히 하고, 예상 결과와 실제 결과의 차이를 반드시 확인하는 습관을 갖기로 함

<br/>


### ▶ 트러블슈팅 (3)

```java
byte result = by + 1;
```

1. **문제점**

* `by`는 `byte`형 변수지만, 정수 리터럴 `1`은 **기본적으로 int 형**으로 처리됨
* 따라서 `by + 1` 연산의 결과 타입은 `int`가 되어 `byte`에 대입할 수 없음
* 컴파일 오류:

  ```
  Type mismatch: cannot convert from int to byte
  ```

2. **해결방안**

* \*\*명시적 형 변환(casting)\*\*을 사용하여 결과를 `byte`로 맞춰줌
* 또는 애초에 `by` 변수를 `int`형으로 선언하여 타입 불일치를 방지

```java
// 해결 1: 캐스팅
byte result = (byte)(by + 1);

// 해결 2: int 사용
int result = by + 1;
```

3. **느낀점**

* 자바는 기본적으로 **정수 리터럴을 int 타입**으로 처리하기 때문에 작은 단위(byte, short)끼리 연산해도 결과는 int가 됨
* 안전성을 위해 자동 변환을 허용하지 않는다는 점에서 **자바의 엄격한 형변환 규칙**을 체감
* 단순한 코드에서도 **자료형과 연산 규칙**을 고려해야 한다는 습관을 배우게 됨

<br/>
<br/>

### ▶ 트러블슈팅 (4)

```java
String ch, a, level, b;
if(avg >= 95) {
    b = "장학생";
}
System.out.printf("%s", b);
```
<br/>

1. **문제점**

* 조건문 내부에서만 `b`가 초기화되므로, 조건을 만족하지 않을 경우 `b`는 **초기화되지 않은 상태로 남게 됨**
* **지역 변수는 명시적으로 초기화하지 않으면 사용 불가**함
* 따라서 컴파일러는 `b`가 사용되기 전에 **값이 할당되지 않았을 가능성**을 탐지하고 오류 발생

  ```bash
  The local variable b may not have been initialized
  ```

<br/>

2. **해결방안**

* 조건문 외부에서 `b`에 **기본값을 초기화**하여 모든 흐름에서 유효하도록 보장
* 또는 조건문에서 초기화되지 않을 수 있는 경우를 **명확하게 처리**


해결방법1) 기본값 할당
```java

String ch, a, level, b = ""; // 또는 "일반", "비장학생" 등 의미 있는 기본값
if(avg >= 95) {
    b = "장학생";
}
System.out.printf("%s", b);
```
<br/>

해결방법2) else 구문 추가
```java
String ch, a, level, b;
if(avg >= 95) {
    b = "장학생";
} else {
    b = "일반";
}
System.out.printf("%s", b);
```
<br/>
3. **느낀점**

* 자바는 **컴파일 타임에 지역 변수의 사용 안전성**을 철저히 검증함
* 조건에 따라 값이 할당되는 구조에서는, **모든 분기에서 변수 초기화가 보장**되어야 함을 인식함
* 특히 **출력(Print)**, 계산 등에 변수 사용 전 초기화 여부를 체크하지 않으면 **예상치 못한 컴파일 오류**로 이어질 수 있음

---

### ▶ 트러블슈팅 (5)

```java
if (check1) {
    System.out.printf(
        (result == (int) result) ? "%d %c %d = %d\n" : "%d %c %d = %.2f\n",
        num1, ch, num2,
        (result == (int) result) ? ((int) result) : result
    );
}
```
<br/>

1. **문제점**

* `System.out.printf()`에서 포맷 문자열을 \*\*삼항 연산자(조건 연산자)\*\*로 분기하고 있음
* `"%d"`는 정수, `"%.2f"`는 실수를 기대하는데, 이에 대응하는 인자 `(int) result`와 `result`는 타입이 다름
* 하지만 삼항 연산자의 반환 타입은 **하나의 공통 타입**으로 수렴되어야 하는데,
  `int`와 `double`은 **공통 조상이 없어 자동 변환되지 않음**
* 이로 인해 컴파일러가 `printf()` 호출 시 포맷과 인자의 타입 매칭을 정확히 판단할 수 없어 **컴파일 오류 발생**

```bash
Type mismatch: cannot convert from double to int
```


<br/>

2. **해결방안**

* 삼항 연산자에서 **기본형(int, double)** 대신 \*\*래퍼 클래스(Integer, Double)\*\*로 변환하고 `(Object)` 캐스팅
* `printf()`는 가변 인자를 `Object...`로 처리하므로, 명확한 타입 변환을 통해 **컴파일 오류를 방지**

```java
if (check1) {
    System.out.printf(
        (result == (int) result) ? "%d %c %d = %d\n" : "%d %c %d = %.2f\n",
        num1, ch, num2,
        (result == (int) result)
            ? (Object)(Integer)((int) result)
            : (Object)(Double) result
    );
}
```


* `int`와 `double`의 공통 조상인 `Object`로 묶어 타입 불일치를 제거
* 자바 컴파일러가 **형식 문자열과 인자의 매칭을 확실히 이해**할 수 있게 도와줌
* 결과적으로 **컴파일 오류를 해결**하면서 원하는 출력 포맷도 유지

<br/>

3. **느낀점**

* 삼항 연산자를 사용할 때는 **리턴 타입의 일치성**이 매우 중요함
* 특히 `printf()`처럼 **가변 인자와 포맷 문자열의 타입 일치를 요구하는 함수**에서는 더욱 조심해야 함
* 자바는 기본형 간의 연산 결과조차도 **형변환이 자동으로 일어나지 않는 경우**가 많기 때문에,
  \*\*명시적 형변환(Object 캐스팅 포함)\*\*에 대한 이해가 중요

<br/>
<br/>

---

### ▶ 트러블슈팅 (6)

```java
System.out.print("숫자열을 입력하시오 : ");
ch = scanner.nextLine();

for(int i=0;i<str;i++) {
		val = ch.charAt(i);
		hap += (int)val;
		}
		System.out.println(hap);
```

<br/>

1. **문제점**

* 문자열로 입력받은 숫자의 각 자리 문자를 `(int)`로 변환해 더하는 과정에서, 문자 `'1'`의 ASCII 코드값인 49가 더해져 결과가 예상과 다름
* `'1'`과 정수 1은 엄연히 다르며, `(int) val`은 \*\*문자 코드값(ASCII)\*\*를 반환함
* 결과적으로 각 자리 숫자의 합이 아니라 각 자리 문자의 ASCII 합이 계산되어 **오답 출력** 발생

```bash
예: "12345" 입력 시, 1+2+3+4+5=15 기대하나, 실제는 49+50+51+52+53=255 출력
```

<br/>

2. **해결방안**

* 문자 `'0'`의 ASCII 값이 48이므로, 각 자리 문자를 정수 숫자로 변환하려면 `'0'`을 빼주면 됨
* 즉, `(int) val - 48` 또는 `val - '0'` 형태로 변환하면 문자 숫자를 올바른 정수로 인식 가능

```java
val = ch.charAt(i);
hap += val - '0'; 
```

* 이렇게 하면 문자 `'1'`이 정수 1로, `'2'`가 정수 2로 변환되어 올바른 합산 결과를 얻음

<br/>

3. **느낀점**

* 자바에서 `char`를 `int`로 변환하면 문자의 ASCII 코드가 반환되므로, 문자 숫자를 정수 숫자로 사용하려면 반드시 `'0'`을 빼는 보정 작업이 필요함
* 문자와 숫자의 내부 표현 방식 차이를 명확히 이해하는 것이 중요
* 기본형 간의 타입 변환 원리뿐 아니라 **문자와 숫자의 논리적 차이**를 인지하는 습관이 문제 해결에 큰 도움이 됨

<br/>
<br/>

---

### ▶ 트러블슈팅 (7) - 문자열 비교 오류

```java
if(id == id && pass == pass){ }
```

<br/>

1. **문제점**

* 로그인 로직에서 사용자 입력값과 저장된 ID, 비밀번호를 비교할 때, **항상 true가 반환되는 현상** 발생
* 두 값이 분명 다름에도 불구하고 조건문이 통과하여, **비밀번호가 틀려도 로그인이 되어버리는 문제** 발생

<br/>

2. **원인 분석**

* `==` 연산자는 기본형(primitive type)에서는 값을 비교하지만, **객체형(String 등)에서는 참조(주소)를 비교**함
* 즉, `id == id`는 **동일한 참조를 비교하므로 항상 true**
* 사용자 입력값인 `tempid`, `temppass`와 저장된 값 `id`, `pass`는 **내용이 같더라도 서로 다른 객체**일 수 있음 → `==` 비교 시 false 반환 또는 로직이 의도와 다르게 작동

<br/>

3. **해결 방안**

* 문자열 값 자체를 비교하려면 `.equals()` 메서드를 사용해야 함
* 아래와 같이 수정하여 **내용 기반 비교**로 로직을 변경함

```java
if(tempid.equals(id) && temppass.equals(pass)){ 
    // 로그인 성공 처리
}
```

* `.equals()`는 두 문자열의 **실제 값(value)** 을 비교하기 때문에, 내용이 동일할 경우만 true를 반환함

<br/>

4. **느낀점**

* 자바의 `==` 연산자가 객체 비교에서는 **주소값을 비교**한다는 사실을 다시금 체감
* 문자열은 특히 사용자 입력처럼 **동적으로 생성되는 경우가 많아**, 참조 비교보다는 **내용 비교가 기본**임을 숙지
* 이번 경험을 통해 비교 연산의 대상이 primitive인지 reference인지 항상 의식하며 코딩하는 습관을 갖게 되었음
* 단순히 코드를 작성하는 것보다, 언어의 **동작 원리와 메모리 구조에 대한 이해**가 얼마나 중요한지를 배움

<br/>

---

### ▶ 트러블슈팅 (8) - Scanner 입력 버퍼 이슈

```java
a = sc.nextInt();

switch(a) {
    case 1:
        System.out.print("아이디 입력 : ");
        id = sc.nextLine();  // ❌ 문제 발생 가능
        System.out.print("비밀번호 입력 : ");
        pw = sc.nextLine();
        break;
}
```

<br/>

1. **문제점**

* `nextInt()` 호출 이후 바로 `nextLine()`을 사용한 결과, **아이디 입력이 생략된 채 비밀번호 입력으로 넘어가는 현상** 발생
* 사용자가 입력을 하지 않았는데도, 콘솔에 “비밀번호 입력:”이 출력되며 흐름이 꼬임

<br/>

2. **원인 분석**

* `Scanner`는 입력 시 줄바꿈 문자(Enter)를 버퍼에 남겨둠
* `nextInt()`는 숫자까지만 읽고 **줄바꿈 문자는 읽지 않음**
* 따라서 `nextLine()`이 호출되면, **남아있던 `\n`을 즉시 읽어버려 빈 문자열을 반환**하게 됨

```bash
예시 입력: 1 ↵  
→ nextInt()는 1만 읽고 ↵는 버퍼에 남음  
→ 다음 nextLine()은 ↵만 읽고 끝남 → id는 빈 문자열
```

<br/>

3. **해결 방안**

✔️ 해결 방안 1 — 불필요한 줄바꿈 제거

```java
a = sc.nextInt();
sc.nextLine(); // 버퍼 비우기

System.out.print("아이디 입력 : ");
id = sc.nextLine();
System.out.print("비밀번호 입력 : ");
pw = sc.nextLine();
```

✔️ 해결 방안 2 — `next()` 사용하여 간단히 처리 (공백 없는 입력 전제 시)

```java
System.out.print("아이디 입력 : ");
id = sc.next(); 
System.out.print("비밀번호 입력 : ");
pw = sc.next();
```

* `next()`는 한 단어(공백 전까지)를 읽으며, 버퍼 이슈 없이 사용 가능
* 단, 입력에 공백이 포함될 경우 `nextLine()`이 필요함

<br/>

4. **느낀점**

* 이번 문제를 통해 **입력 방식의 차이와 Scanner의 버퍼 처리 방식**을 명확히 이해하게 되었음
* 특히, 자바에서의 `nextInt()`와 `nextLine()`이 **서로 호환되지 않는 이유**를 근본적으로 분석해봄으로써, 입력 처리에 대한 신뢰도를 높이는 계기가 되었음
* 실무에서는 사용자 경험이 중요한 만큼, **입력 오류 하나도 프로그램 전체 흐름에 영향을 줄 수 있음을 체감**
* 앞으로는 단순한 입력 처리도 **데이터 흐름과 메모리 동작을 고려해 설계**할 수 있는 개발자가 되기 위해 노력할 것임

<br/>
<br/>


아래는 요청하신 내용을 기반으로 \*\*트러블슈팅 (9)\*\*을 실무진이 감탄할 만큼 구조적으로, 전문성을 갖춰 정리한 버전입니다. (이전 트러블슈팅(7)의 형식에 맞춤 + 실전 개발 환경에서 활용 가능하도록 인사이트 포함)

---

### ▶ 트러블슈팅 (9) - 배열 초기화 누락으로 인한 `NullPointerException`

```java
public class ArrayExUpgrade1 { 
    public static void main(String[] args) { 
        char[] answer = {'A', 'C', 'B', 'D', 'A'}; 
        char[] correct = null; // 문제 지점
        Scanner sc = new Scanner(System.in); 
        for(int i = 0; i < answer.length; i++) { 
            System.out.print("입력 > "); 
            correct[i] = sc.next().charAt(0); // 여기서 예외 발생
        } 
        ...
    } 
}
```

<br/>



### 1. **문제점**

* 배열 `correct`가 선언만 되어 있고, 실제 메모리 공간은 할당되지 않음 (`null` 상태)
* 이후 `correct[i] = ...`에서 **존재하지 않는 배열에 접근하려 하면서 `NullPointerException` 발생**
* 코드 실행 시점에는 **컴파일 에러 없이 실행되지만**, 런타임에서 예외가 발생해 프로그램이 중단됨



### 2. **원인 분석**

* 자바에서 배열도 객체이므로, `char[] correct = null;`은 **객체 참조 변수만 선언**한 상태
* `null`은 참조 대상이 없음을 의미하며, 이 상태에서 `correct[i]`로 접근하면 **존재하지 않는 객체의 멤버에 접근**하는 것이므로 예외 발생
* 자바에서 `NullPointerException`은 **가장 흔하면서도 치명적인 런타임 오류** 중 하나로, 보통 아래 상황에서 발생:

  * 객체 생성 없이 필드/메서드 호출
  * null 배열 접근
  * 메서드 리턴값이 null인데 바로 접근



### 3. **해결 방안**

#### ✅ 올바른 배열 생성

```java
char[] correct = new char[answer.length];
```

* `correct` 배열을 `answer.length` 크기로 생성함으로써, **입력값 저장을 위한 메모리 공간을 확보**
* 이제 `correct[i]`로 접근해도 예외 없이 정상 작동
* `answer.length`를 기준으로 배열 크기를 동적으로 지정하면, 추후 answer 배열이 바뀌더라도 유연하게 대응 가능



### 4. **느낀점**

* `null` 상태는 단순한 "빈 값"이 아니라, **메모리에 아예 존재하지 않는 객체 상태**라는 점을 실감했다
* 배열은 객체이므로 **생성 (`new`) 없이는 사용 불가** — 선언과 동시에 생성하는 습관이 중요함
* 자바에서는 선언과 동시에 초기화를 하지 않으면 참조형 변수는 `null`로 초기화되므로, 해당 상태에서 직접 접근은 금물

<br/>
<br/>


---

### ▶ 트러블슈팅 (10) - 배열 인덱스 초과 오류 (`ArrayIndexOutOfBoundsException`)

```java
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5  
	at com.company.java007_ex.ArrayEx008.main(ArrayEx008.java:17)
```



### 1. **문제점**

```java
int i = 0;

for(i = 0; i < name.length; i++) {
    aver[i] = (int) ((kor[i] + eng[i] + mat[i]) / 3.0);
}

System.out.println(aver[i]); // <-- 여기서 예외 발생!
```

* 위 코드에서 마지막 `System.out.println(aver[i]);` 문장에서 **`ArrayIndexOutOfBoundsException` 예외 발생**
* 콘솔 메시지: `Index 5 out of bounds for length 5` → `aver[5]` 접근 시도 → 유효 인덱스 범위 `[0 ~ 4]`



### 2. **원인 분석**

#### 📌 핵심 원인

* `for` 루프가 끝난 후 `i` 값은 `name.length`와 동일한 값 (예: 5)
* 자바 배열의 유효 인덱스는 `0 ~ length - 1`까지이며, `aver[5]`는 존재하지 않음
* 따라서 `System.out.println(aver[i]);`는 **배열의 범위를 초과한 접근 시도로 인해 런타임 예외 발생**

#### 🔍 디버깅 흐름

* `for(i = 0; i < name.length; i++)` → i는 0부터 4까지 증가
* 반복문 종료 시 `i == name.length` → 즉, `i == 5`
* 그 상태에서 `aver[i]`는 `aver[5]`를 의미 → **배열 경계 초과**



### 3. **해결 방안**

#### ✅ 방법 1: 반복문 내에서 출력하기

```java
for(int i = 0; i < name.length; i++) {
    aver[i] = (int) ((kor[i] + eng[i] + mat[i]) / 3.0);
    System.out.println(aver[i]); // 안전하게 접근 가능
}
```

#### ✅ 방법 2: 루프 외부에서 출력 시 `i - 1` 사용

```java
System.out.println(aver[i - 1]); // 루프 종료 후 i == name.length 이므로 마지막 인덱스는 i - 1
```

### 4. **느낀점**

* 배열 인덱스는 항상 **0부터 시작**하고, **`length - 1`까지 접근 가능**하다는 점을 실수로 간과함
* 반복문이 끝난 뒤 루프 변수 `i`가 얼마나 증가했는지 **루프 외부에서 사용하는 경우 반드시 주의**해야 함
* 자바는 **배열 범위 초과에 대해 런타임에서 엄격하게 예외를 발생시키므로**, 경계 조건을 정확히 확인해야 함
* 이 경험을 통해 **루프 인덱스를 외부에서 사용할 경우 상태 추적이 필수적**이며, 명시적인 인덱스 사용의 중요성을 인식함


<br/>
<br/>

---

## 📌 포트폴리오

### 1) JAVA를 활용한  BANK 시스템

```java
package com.company.java006_ex;

import java.util.Scanner;

public class Bank_Var1_Game2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int level = 0, age = 0, left = 0, come = 0, out = 0, old_level = 0, exp = 0;
        String ids = " ", pws = " ", id_oks = " ", pw_oks = " ", past_id = "";
        char yes = ' ';
        boolean check = false;
        boolean add = false;
        boolean login = false;
        boolean level_up = false;
        boolean rank_check = false;

        System.out.println("🧠 [뱅키] 안녕하세요! GSH_BANK에 오신 것을 환영합니다!");
        System.out.println("🎮 뱅키와 함께하는 게임형 은행 시스템을 즐겨보세요!");

        for (;;) {
            switch (level) {
                case 0:
                    System.out.println("\n===== GSH_BANK MENU =====");
                    System.out.println("1. 추가 (회원가입)");
                    System.out.println("2. 조회");
                    System.out.println("3. 입금");
                    System.out.println("4. 출금");
                    System.out.println("5. 삭제");
                    System.out.println("9. 종료");
                    System.out.print("입력 : ");
                    level = scanner.nextInt();
                    scanner.nextLine();

                    if (level >= 1 && level <= 5 || level == 9) {
                        if (!add && level != 1) {
                            System.out.println("🧠 [뱅키] 먼저 회원가입 해주세요! (1번)");
                            level = 0;
                            continue;
                        }
                    } else {
                        System.out.println("⚠ 올바른 메뉴를 선택해주세요.");
                        level = 0;
                        continue;
                    }
                    break;

                case 1:
                    System.out.println("\n👤 [회원가입]");
                    System.out.print("ID : ");
                    ids = scanner.nextLine();
                    if (past_id.equals(ids)) {
                        System.out.println("⚠ 이전과 같은 ID는 사용할 수 없습니다.");
                        continue;
                    }
                    System.out.print("PW : ");
                    pws = scanner.nextLine();
                    System.out.print("나이 : ");
                    age = scanner.nextInt();
                    System.out.print("초기 잔액 : ");
                    left = scanner.nextInt();
                    scanner.nextLine();

                    if (age <= 18) {
                        System.out.println("⚠만 19세 미만은 해당 서비스를 이용하실 수 없습니다.");
                        level = 0;
                        break;
                    }

                    id_oks = ids;
                    pw_oks = pws;
                    add = true;

                    System.out.println("🎉 [뱅키] 환영합니다, " + ids + "님!");
                    level = 0;
                    break;

                case 2:
                    if (!login) {
                        System.out.println("\n🔒 [조회 기능] 로그인이 필요합니다.");
                        old_level = level;
                        level = 6;
                        break;
                    }
                    login = false;

                    System.out.println("\n📊 [잔액 조회]");
                    System.out.println("현재 잔액: " + left + "원");
                    // 등급 직접 출력
                    if (left >= 1000000) {
                        System.out.println("🏅 고객 등급: 💎 Diamond VIP");
                    } else if (left >= 500000) {
                        System.out.println("🏅 고객 등급: 🥇 Gold 고객");
                    } else if (left >= 100000) {
                        System.out.println("🏅 고객 등급: 🥈 Silver 고객");
                    } else {
                        System.out.println("🏅 고객 등급: 🥉 Bronze 고객");
                    }

                    level = 0;
                    break;

                case 3:
                    if (!login) {
                        System.out.println("\n🔒 [입금 기능] 로그인이 필요합니다.");
                        old_level = level;
                        level = 6;
                        break;
                    }
                    login = false;

                    System.out.println("\n💰 [입금 기능]");
                    System.out.println("현재 잔액: " + left + "원");

                    while (true) {
                        System.out.print("입금 금액 입력: ");
                        come = scanner.nextInt();
                        scanner.nextLine();

                        if (come > 0) {
                            left += come;
                            exp += (come / 10);
                            System.out.println("✅ 입금 완료! 현재 잔액: " + left + "원");
                            System.out.println("✨ 경험치 +10 ▶ 현재 경험치: " + exp);

                            // 등급 직접 출력
                            if (left >= 1000000) {
                                System.out.println("🏅 고객 등급: 💎 Diamond VIP");
                            } else if (left >= 500000) {
                                System.out.println("🏅 고객 등급: 🥇 Gold 고객");
                            } else if (left >= 100000) {
                                System.out.println("🏅 고객 등급: 🥈 Silver 고객");
                            } else {
                                System.out.println("🏅 고객 등급: 🥉 Bronze 고객");
                            }

                            if (exp >= 100) {
                                System.out.println("🎉 레벨업! 보너스 지급 예정!");
                                exp = 0;
                                level_up = true;
                            }

                            // 🎁 복권 이벤트
                            if (level_up == true) {
                                int bonus = (int) (Math.random() * 3000);
                                System.out.println("🎉 [레벨업 복권 보너스] 보너스 " + bonus + "원 당첨!");
                                System.out.println("[묻고 떠블로가!] 주사위 숫자가 50미만일 경우 - 보너스*2 / 50이상일경우 - 0원");
                                System.out.println("[묻고 떠블로가!] 이벤트에 도전하시겠습니까? (Y / N)");
                                yes = scanner.next().charAt(0);
                                if (yes == 'Y' || yes == 'y') {
                                    int chance = (int) (Math.random() * 100);
                                    if (chance < 50) {
                                        bonus *= 2;
                                        left += bonus;
                                        System.out.println("🎉 축하드립니다!");
                                        System.out.println("🎉 [묻고 떠블로가!] 이벤트 당첨! " + bonus + "원 지급!");
                                    } else {
                                        System.out.println("주사위의 숫자는 " + chance + " 입니다.");
                                        System.out.println("😢 아깝네요. 다음 기회에!");
                                    }
                                } else {
                                    System.out.println("🎉 [레벨업 복권 보너스] 보너스 " + bonus + "원 지급!");
                                    left += bonus;
                                }

                                level_up = false;
                            }

                            // 🎲 잔액 이스터에그
                            if (left == 77777) {
                                System.out.println("🎰 [럭키세븐 이벤트]");
                                System.out.print("주사위를 선택하세요 (1~6): ");
                                int choice = scanner.nextInt();
                                scanner.nextLine();
                                int rolled = (int) (Math.random() * 6) + 1;
                                if (choice == rolled) {
                                    System.out.println("🎊 주사위 대성공! 보너스 50000원 지급!");
                                    left += 50000;
                                } else {
                                    System.out.println("주사위의 숫자는 " + rolled + " 입니다.");
                                    System.out.println("😢 아깝네요. 다음 기회에!");
                                }
                            }

                            level = 0;
                            break;
                        } else {
                            System.out.println("❌ 음수나 0은 입금할 수 없습니다.");
                        }
                    }
                    break;

                case 4:
                    if (!login) {
                        System.out.println("\n🔒 [출금 기능] 로그인이 필요합니다.");
                        old_level = level;
                        level = 6;
                        break;
                    }
                    login = false;

                    System.out.println("\n🏧 [출금 기능]");
                    while (true) {
                        System.out.print("출금 금액 입력: ");
                        out = scanner.nextInt();
                        scanner.nextLine();
                        if (out <= left) {
                            left -= out;
                            exp += 10;
                            System.out.println("✅ 출금 완료! 현재 잔액: " + left + "원");
                            System.out.println("✨ 경험치 +10 ▶ 현재 경험치: " + exp);

                            // 등급 직접 출력
                            if (left >= 1000000) {
                                System.out.println("🏅 고객 등급: 💎 Diamond VIP");
                            } else if (left >= 500000) {
                                System.out.println("🏅 고객 등급: 🥇 Gold 고객");
                            } else if (left >= 100000) {
                                System.out.println("🏅 고객 등급: 🥈 Silver 고객");
                            } else {
                                System.out.println("🏅 고객 등급: 🥉 Bronze 고객");

                            } // 등급 출력 끝

                            if (exp >= 100) {
                                System.out.println("🎉 레벨업! 보너스 지급 예정!");
                                exp = 0;
                            }

                            level = 0;
                            break;
                        } else {
                            System.out.println("❌ 출금 금액이 잔액보다 많습니다!");
                        }
                    }
                    break;

                case 5:
                    if (!login) {
                        System.out.println("\n🔒 [삭제 기능] 로그인이 필요합니다.");
                        old_level = level;
                        level = 6;
                        break;
                    }
                    login = false;

                    System.out.println("\n🗑️ [계정 삭제]");
                    past_id = id_oks;
                    id_oks = " ";
                    pw_oks = " ";
                    left = 0;
                    age = 0;
                    add = false;
                    exp = 0;
                    System.out.println("👋 계정이 성공적으로 삭제되었습니다.");
                    level = 0;
                    break;

                case 6:
                    System.out.println("\n🔐 [로그인]");
                    while (true) {
                        System.out.print("ID : ");
                        ids = scanner.nextLine();
                        System.out.print("PW : ");
                        pws = scanner.nextLine();
                        if (ids.equals(id_oks) && pws.equals(pw_oks)) {
                            level = old_level;
                            login = true;
                            System.out.println("✅ 로그인 성공!");
                            break;
                        } else {
                            System.out.println("❌ ID 또는 PW가 틀렸습니다.");
                        }
                    }
                    break;

                case 7:
                    // case 7은 필요 없으므로 제거해도 됩니다 (등급 출력이 메서드 없이 구현됨)
                    level = old_level;
                    break;

                case 9:
                    System.out.println("\n👋 [뱅키] 이용해주셔서 감사합니다, " + id_oks + "님!");
                    check = true;
                    break;
            }

            if (check) {
                System.out.println("프로그램이 종료되었습니다.");
                break;
            }
        }
    }
}
```



<br/>
<br/>




---

## 📌 이론 정리 (GitHub)




<br/>
<br/>

---

## 📌 이론 정리 (Web)




<br/>
<br/>

---

## 📌 이론 정리 (Java)



<br/>
<br/>

---

## 참고문헌

- [Git 공식 문서](https://git-scm.com/doc)  
- [Markdown 가이드](https://www.markdownguide.org/basic-syntax/)  
- [VS Code 공식 사이트](https://code.visualstudio.com/)  
- [AI 프롬프트 작성 팁](https://learn.microsoft.com/en-us/azure/ai-foundry/openai/concepts/prompt-engineering?tabs=chat)

<br/>
<br/>

---

