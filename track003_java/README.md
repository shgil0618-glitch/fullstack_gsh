
# 🚀 실행력과 협업에 강한 풀스택 개발자 – 길상현의 개발 여정

> 완벽에 머무르기보다, **끝까지 완성해내는 개발자**
> 기획부터 배포까지 전 과정을 주도하며, **사용자 흐름을 설계하고 문제를 끝까지 해결**해왔습니다.

단순한 기능 구현을 넘어,
**CS 기반의 구조적 문제 해결 능력**과
**팀 프로젝트에서의 실전 협업 경험**으로 
현장에서 바로 통하는 역량을 증명해왔습니다.

<br/>
<br/>

---
<!-- 이미지 (조절하는 법) -->
<!-- 이름, 이메일, 깃허브주소, 포트폴리오  2*4의 테이블 형식으로 -->
## Contact & Link

<!-- ![프로필](./userimage.png) -->
<img src="./userimage.png" alt="프로필" width = "100">

| | |
|-|-|
|이름|길상현|
|이메일|shgil0618@gmail.com|
|깃허브주소|https://github.com/shgil0618-glitch/fullstack_gsh.git|
<!--
|포트폴리오|**추후 추가예정**|
-->

<br/>
<br/>

---

## 📌 Golds – 실무 중심의 개발 역량 강화 목표

* **GitHub 핵심 기능을 직접 실습하며**, 버전 관리와 협업에 필요한 기초를 탄탄히 다졌습니다.
* **Markdown을 활용한 개발 문서화** 역량을 키워, 누구나 이해할 수 있는 기록을 남기는 습관을 길렀습니다.
* **GitHub Workflow를 실전 프로젝트에 적용**, 팀원과의 효율적인 협업을 경험하며 CI/CD 개념의 기초도 익혔습니다.
* **AI 도구(GitHub Copilot 등)를 활용한 개발 환경을 체험**, 생산성과 학습 효율을 높이는 방법을 적극적으로 탐구했습니다.

<!-- ### 💡 왜 이렇게 다듬었을까요?

* ✔️ **행동 중심 문장** → 단순히 “했다”보다 \*\*“어떻게, 왜”\*\*를 담으면 신뢰도가 올라갑니다.
* ✔️ **실무 맥락에 연결** → 실무진은 "우리 팀에 와서 어떻게 기여할 수 있을까?"를 봅니다.
* ✔️ **도구를 썼다 → 능동적으로 익혔다** → 도구 사용은 기본, **활용 목적과 결과**가 중요합니다.
-->
<br/>
<br/>

<!-- cs와 연결지어서
---

### 📌 기술 스택 & 실무 기반 CS 역량 

| 기술 스택                        | 역할 및 기능 이해                  | 실무적 활용 및 경험 포인트                               |
| ---------------------------- | --------------------------- | --------------------------------------------- |
| **Git & GitHub**             | 분산 버전 관리, 브랜치 전략, 협업 워크플로우  | PR 리뷰, Merge Conflict 해결, Git Flow 적용 프로젝트 경험 |
| **Markdown**                 | 기술 문서 작성, README, 회고 문서화 도구 | 협업 문서/이슈 템플릿 작성, Notion 연동 정리 습관화             |
| **VS Code**                  | 경량 IDE, 디버깅, 확장 기능 구성       | GitLens, Live Server, Copilot 등 실무 확장 기능 활용   |
| **HTML5**                    | 시맨틱 구조, 접근성 고려 마크업          | 구조적 DOM 설계, SEO 및 스크린리더 고려 개발 경험              |
| **CSS3**                     | 반응형 레이아웃, Flex/Grid, 애니메이션  | 모바일 대응 UI, 미디어쿼리 활용 경험                        |
| **AI 도구 (Copilot, ChatGPT)** | 생산성 도구, 코드 힌트, 에러 진단 보조     | 코드 리뷰/리팩토링 보조, 모르는 개념 검증 및 빠른 테스트             |


### ✅ 실무진이 좋아하는 구성 포인트:

* **왼쪽 → 기술 명칭**, 가운데 → **기술 개념**, 오른쪽 → **어떻게 활용했는지**
* 실전 경험이 보이는 **구체 키워드 포함** (예: conflict 해결, Git Flow, 반응형 UI)
* 단순히 "할 줄 안다"가 아니라 **이해하고 활용했다**는 점을 강조
-->

<!--
1. 개발자 포트폴리오 readme.md 작성중인데, 이 기술스택을 보고 실무진들이 바로 뽑아야겠다라는 생각이 들게 다음의 기술스택을 cs역량과 연결지어서 작성해줘.

2. 위의 내용에서 활용능력부분에서 강조할부분을 굵고 색상들어가게해줘
-->

<!--
---

## 📌 기술스택 기반 CS역량

* **Git & GitHub**

  * 분산 버전 관리 시스템(DVCS)의 원리 이해 및 활용
  * 협업 과정에서 <b style="color:#f39c12">브랜치 전략(Git Flow, Trunk-based)</b> 적용 → 안정적인 개발 사이클 유지
  * 충돌 해결 및 코드 리뷰 경험을 통한 <b style="color:#27ae60">소프트웨어 공학적 협업 역량</b> 확보

* **Markdown**

  * <b style="color:#3498db">가독성 높은 문서화</b> 및 개발 문서 작성 능력
  * README, API 문서, 위키를 통해 <b style="color:#27ae60">기술 커뮤니케이션 역량</b> 강화
  * 명확한 표현으로 <b style="color:#9b59b6">팀 생산성 극대화</b>

* **VS Code**

  * 확장 플러그인 기반 <b style="color:#f39c12">개발 환경 최적화</b> 능력
  * <b style="color:#27ae60">디버깅 · Linting · Formatter</b> 적용을 통한 코드 품질 관리

* **HTML5**

  * 시맨틱 태그 활용으로 <b style="color:#27ae60">정보 구조화 및 접근성 개선</b>
  * DOM과 웹 표준 이해로 <b style="color:#3498db">크로스 플랫폼 호환성 보장</b>

* **CSS3**

  * Flexbox · Grid 시스템을 통한 <b style="color:#f39c12">효율적 레이아웃 설계</b>
  * 애니메이션 · 반응형 디자인 적용 → <b style="color:#27ae60">사용자 경험(UX) 최적화</b>

* **AI 프롬프트 엔지니어링**

  * 자연어 입력 구조 최적화로 <b style="color:#f39c12">문제 정의 및 요구사항 추출</b>
  * 프롬프트 최적화를 통한 <b style="color:#27ae60">자동화 · 생산성 증대</b>
  * AI 협업을 통한 <b style="color:#9b59b6">문제 해결 능력 가속화</b>
-->
---

## 📌 기술스택 기반 CS역량

| 기술스택                         | CS 기반 이해                   | 활용 능력                                                                                                                                                                  |
| ---------------------------- | -------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Git & GitHub**             | 분산 버전 관리 시스템(DVCS), 브랜치 전략 | 협업 과정에서 <b style="color:#f39c12">브랜치 전략(Git Flow, Trunk-based)</b> 적용, 충돌 해결 및 코드 리뷰를 통한 <b style="color:#27ae60">소프트웨어 공학적 협업 역량</b> 확보                               |
| **Markdown**                 | 문서 구조화, 개발 지식 전달           | <b style="color:#3498db">가독성 높은 문서화</b> 및 README, API 문서, 위키 작성 → <b style="color:#27ae60">기술 커뮤니케이션 역량</b> 강화, 명확한 표현으로 <b style="color:#9b59b6">팀 생산성 극대화</b>        |
| **VS Code**                  | IDE 동작 원리, 코드 품질 관리        | 확장 플러그인 기반 <b style="color:#f39c12">개발 환경 최적화</b>, <b style="color:#27ae60">디버깅 · Linting · Formatter</b> 적용을 통한 코드 품질 관리                                              |
| **HTML5**                    | 웹 표준, DOM 구조, 시맨틱 태그       | 시맨틱 태그 활용으로 <b style="color:#27ae60">정보 구조화 및 접근성 개선</b>, DOM 및 웹 표준 이해로 <b style="color:#3498db">크로스 플랫폼 호환성 보장</b>                                                   |
| **CSS3**                     | 렌더링 엔진, 박스 모델, 레이아웃 알고리즘   | Flexbox · Grid 시스템을 통한 <b style="color:#f39c12">효율적 레이아웃 설계</b>, 애니메이션 및 반응형 디자인 적용으로 <b style="color:#27ae60">사용자 경험(UX) 최적화</b>                                      |
| **AI 도구 (Copilot, ChatGPT)** | NLP 모델 구조, AI 기반 자동화 활용    | 자연어 입력 구조 최적화로 <b style="color:#f39c12">문제 정의 및 요구사항 추출</b>, 프롬프트 최적화를 통한 <b style="color:#27ae60">자동화 · 생산성 증대</b>, AI 협업으로 <b style="color:#9b59b6">문제 해결 능력 가속화</b> |


<br/>
<br/>

---
<!-- java, html+css+js/jquery ... 
## 📌 포트폴리오

``추후 업데이트 예정``


<br/>
<br/>

---
-->
<!-- 매일 올리기 -->
## 📌 트러블 슈팅 (Java에서 발생)
<br/>

### ▶트러블 슈팅(1)

```java
package com.company.Java001_ex;

public class A003_ex {
    public static void main(string[] args) {
        System.out.printf("이름 : %s  나이: %d", "길동", 12);
    }
}
```
```bash
Error:(5, 24) java: cannot find symbol
  symbol:   class string
  location: class com.company.java001_ex.A003_ex
```

1. **문제점**
   * Java는 **대소문자를 엄격히 구분**하기 때문에, `string`과 같은 잘못된 표기는 컴파일 에러를 발생시킨다. 또한, 패키지명은 관례적으로 **소문자**를 사용해야 가독성과 유지보수성이 높아진다.

2. **해결방안**
   * `string[] args` → `String[] args` 로 수정하여 올바른 타입 지정
   * `package com.company.Java001_ex;` → `package com.company.java001_ex;` 로 변경하여 네이밍 컨벤션 준수

3. **느낀점**
   * 이번 오류를 통해 **사소해 보이는 대소문자 차이도 프로그램 실행 여부에 직접적인 영향을 준다는 것**을 다시 한 번 체감했다. 앞으로는 단순히 코드를 작성하는 것에서 끝나지 않고, **언어의 문법적 특징과 컨벤션을 의식적으로 지키는 습관**을 들여 더 안정적이고 읽기 쉬운 코드를 작성해야겠다.

<br/>

### ▶트러블 슈팅(2)

```java
public class VarEx002 {
	public static void main(String[] args) {
		int a;
		a = 10;
		int b;
		b = 3;
		float c;
		c = a/b;
		System.out.println("10 / 3 =" +(a/b));
		System.out.println("10 / 3 = "+c);	
		System.out.printf("%d / %d = %f\n",a,b,c);
   }
}
```
```bash
결과값
10 / 3 = 3
10 / 3 = 3.0
10 / 3 = 3.000000
```

1. **문제점**
   * 변수 c를 float로 선언했음에도 불구하고 결과가 3.0, 3.000000으로 정수 나눗셈 결과를 그대로 보여줌
   * 이유: a와 b가 정수형(int) 이므로, 나눗셈 연산 a/b가 정수 나눗셈으로 수행됨 → 소수점 이하가 버려짐
   * 즉, 실수형 변수에 저장했더라도 연산 과정 자체가 정수라 실제 계산값은 이미 손실됨

2. **해결방안**
   * 나눗셈을 수행하기 전에 한쪽 혹은 양쪽을 실수형으로 캐스팅
```java
   c = (float)a / b;
```

3. **느낀점**
   * 겉보기에는 변수 타입만 바꿔도 될 것 같지만, 연산 과정에서 자료형이 우선적으로 적용됨을 깨달음
   * 사소한 타입 문제 하나가 결과를 완전히 달라지게 할 수 있다는 점에서 자료형 선택과 연산 순서의 중요성을 배웠음
   * 앞으로는 실수 연산 시 정수/실수 타입 구분을 명확히 하고, 예상 결과와 실제 결과의 차이를 반드시 확인하는 습관을 갖기로 함

<br/>


### ▶ 트러블슈팅 (3)

```java
byte result = by + 1;
```

1. **문제점**

* `by`는 `byte`형 변수지만, 정수 리터럴 `1`은 **기본적으로 int 형**으로 처리됨
* 따라서 `by + 1` 연산의 결과 타입은 `int`가 되어 `byte`에 대입할 수 없음
* 컴파일 오류:

  ```
  Type mismatch: cannot convert from int to byte
  ```

2. **해결방안**

* \*\*명시적 형 변환(casting)\*\*을 사용하여 결과를 `byte`로 맞춰줌
* 또는 애초에 `by` 변수를 `int`형으로 선언하여 타입 불일치를 방지

```java
// 해결 1: 캐스팅
byte result = (byte)(by + 1);

// 해결 2: int 사용
int result = by + 1;
```

3. **느낀점**

* 자바는 기본적으로 **정수 리터럴을 int 타입**으로 처리하기 때문에 작은 단위(byte, short)끼리 연산해도 결과는 int가 됨
* 안전성을 위해 자동 변환을 허용하지 않는다는 점에서 **자바의 엄격한 형변환 규칙**을 체감
* 단순한 코드에서도 **자료형과 연산 규칙**을 고려해야 한다는 습관을 배우게 됨

<br/>
<br/>

### ▶ 트러블슈팅 (4)

```java
String ch, a, level, b;
if(avg >= 95) {
    b = "장학생";
}
System.out.printf("%s", b);
```
<br/>

1. **문제점**

* 조건문 내부에서만 `b`가 초기화되므로, 조건을 만족하지 않을 경우 `b`는 **초기화되지 않은 상태로 남게 됨**
* **지역 변수는 명시적으로 초기화하지 않으면 사용 불가**함
* 따라서 컴파일러는 `b`가 사용되기 전에 **값이 할당되지 않았을 가능성**을 탐지하고 오류 발생

  ```bash
  The local variable b may not have been initialized
  ```

<br/>

2. **해결방안**

* 조건문 외부에서 `b`에 **기본값을 초기화**하여 모든 흐름에서 유효하도록 보장
* 또는 조건문에서 초기화되지 않을 수 있는 경우를 **명확하게 처리**


해결방법1) 기본값 할당
```java

String ch, a, level, b = ""; // 또는 "일반", "비장학생" 등 의미 있는 기본값
if(avg >= 95) {
    b = "장학생";
}
System.out.printf("%s", b);
```
<br/>

해결방법2) else 구문 추가
```java
String ch, a, level, b;
if(avg >= 95) {
    b = "장학생";
} else {
    b = "일반";
}
System.out.printf("%s", b);
```
<br/>
3. **느낀점**

* 자바는 **컴파일 타임에 지역 변수의 사용 안전성**을 철저히 검증함
* 조건에 따라 값이 할당되는 구조에서는, **모든 분기에서 변수 초기화가 보장**되어야 함을 인식함
* 특히 **출력(Print)**, 계산 등에 변수 사용 전 초기화 여부를 체크하지 않으면 **예상치 못한 컴파일 오류**로 이어질 수 있음

---

### ▶ 트러블슈팅 (5)

```java
if (check1) {
    System.out.printf(
        (result == (int) result) ? "%d %c %d = %d\n" : "%d %c %d = %.2f\n",
        num1, ch, num2,
        (result == (int) result) ? ((int) result) : result
    );
}
```
<br/>

1. **문제점**

* `System.out.printf()`에서 포맷 문자열을 \*\*삼항 연산자(조건 연산자)\*\*로 분기하고 있음
* `"%d"`는 정수, `"%.2f"`는 실수를 기대하는데, 이에 대응하는 인자 `(int) result`와 `result`는 타입이 다름
* 하지만 삼항 연산자의 반환 타입은 **하나의 공통 타입**으로 수렴되어야 하는데,
  `int`와 `double`은 **공통 조상이 없어 자동 변환되지 않음**
* 이로 인해 컴파일러가 `printf()` 호출 시 포맷과 인자의 타입 매칭을 정확히 판단할 수 없어 **컴파일 오류 발생**

```bash
Type mismatch: cannot convert from double to int
```


<br/>

2. **해결방안**

* 삼항 연산자에서 **기본형(int, double)** 대신 \*\*래퍼 클래스(Integer, Double)\*\*로 변환하고 `(Object)` 캐스팅
* `printf()`는 가변 인자를 `Object...`로 처리하므로, 명확한 타입 변환을 통해 **컴파일 오류를 방지**

```java
if (check1) {
    System.out.printf(
        (result == (int) result) ? "%d %c %d = %d\n" : "%d %c %d = %.2f\n",
        num1, ch, num2,
        (result == (int) result)
            ? (Object)(Integer)((int) result)
            : (Object)(Double) result
    );
}
```


* `int`와 `double`의 공통 조상인 `Object`로 묶어 타입 불일치를 제거
* 자바 컴파일러가 **형식 문자열과 인자의 매칭을 확실히 이해**할 수 있게 도와줌
* 결과적으로 **컴파일 오류를 해결**하면서 원하는 출력 포맷도 유지

<br/>

3. **느낀점**

* 삼항 연산자를 사용할 때는 **리턴 타입의 일치성**이 매우 중요함
* 특히 `printf()`처럼 **가변 인자와 포맷 문자열의 타입 일치를 요구하는 함수**에서는 더욱 조심해야 함
* 자바는 기본형 간의 연산 결과조차도 **형변환이 자동으로 일어나지 않는 경우**가 많기 때문에,
  \*\*명시적 형변환(Object 캐스팅 포함)\*\*에 대한 이해가 중요


---

### ▶ 트러블슈팅 (6)

```java
System.out.print("숫자열을 입력하시오 : ");
ch = scanner.nextLine();

for(int i=0;i<str;i++) {
		val = ch.charAt(i);
		hap += (int)val;
		}
		System.out.println(hap);
```

<br/>

1. **문제점**

* 문자열로 입력받은 숫자의 각 자리 문자를 `(int)`로 변환해 더하는 과정에서, 문자 `'1'`의 ASCII 코드값인 49가 더해져 결과가 예상과 다름
* `'1'`과 정수 1은 엄연히 다르며, `(int) val`은 \*\*문자 코드값(ASCII)\*\*를 반환함
* 결과적으로 각 자리 숫자의 합이 아니라 각 자리 문자의 ASCII 합이 계산되어 **오답 출력** 발생

```bash
예: "12345" 입력 시, 1+2+3+4+5=15 기대하나, 실제는 49+50+51+52+53=255 출력
```

<br/>

2. **해결방안**

* 문자 `'0'`의 ASCII 값이 48이므로, 각 자리 문자를 정수 숫자로 변환하려면 `'0'`을 빼주면 됨
* 즉, `(int) val - 48` 또는 `val - '0'` 형태로 변환하면 문자 숫자를 올바른 정수로 인식 가능

```java
val = ch.charAt(i);
hap += val - '0'; 
```

* 이렇게 하면 문자 `'1'`이 정수 1로, `'2'`가 정수 2로 변환되어 올바른 합산 결과를 얻음

<br/>

3. **느낀점**

* 자바에서 `char`를 `int`로 변환하면 문자의 ASCII 코드가 반환되므로, 문자 숫자를 정수 숫자로 사용하려면 반드시 `'0'`을 빼는 보정 작업이 필요함
* 문자와 숫자의 내부 표현 방식 차이를 명확히 이해하는 것이 중요
* 기본형 간의 타입 변환 원리뿐 아니라 **문자와 숫자의 논리적 차이**를 인지하는 습관이 문제 해결에 큰 도움이 됨

<br/>
<br/>

---

## 참고문헌

- [Git 공식 문서](https://git-scm.com/doc)  
- [Markdown 가이드](https://www.markdownguide.org/basic-syntax/)  
- [VS Code 공식 사이트](https://code.visualstudio.com/)  
- [AI 프롬프트 작성 팁](https://learn.microsoft.com/en-us/azure/ai-foundry/openai/concepts/prompt-engineering?tabs=chat)

<br/>
<br/>

---

